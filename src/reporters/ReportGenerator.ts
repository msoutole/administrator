/**
 * Report generator for analysis results
 */

import { AnalysisResult } from '../types';
import { formatDuration } from '../utils/helpers';

export class ReportGenerator {
  generateMarkdown(result: AnalysisResult): string {
    const sections = [
      this.generateHeader(result),
      this.generateSummary(result),
      this.generateScoreBreakdown(result),
      this.generateMetricsDetails(result),
      this.generateRecommendations(result),
      this.generateFooter(result),
    ];

    return sections.join('\n\n');
  }

  generateJson(result: AnalysisResult): string {
    return JSON.stringify(result, null, 2);
  }

  private generateHeader(result: AnalysisResult): string {
    return `# Repository Analysis Report

**Repository:** [${result.repository.owner}/${result.repository.name}](${result.repository.url})
**Analysis Date:** ${result.timestamp.toISOString()}
**Duration:** ${formatDuration(result.duration)}

---`;
  }

  private generateSummary(result: AnalysisResult): string {
    const { repository, score } = result;

    return `## Summary

- **Overall Score:** ${score.overall}/100 (Grade: ${score.grade})
- **Language:** ${repository.language || 'N/A'}
- **Stars:** â­ ${repository.stars}
- **Forks:** ðŸ”± ${repository.forks}
- **License:** ${repository.license || 'None'}`;
  }

  private generateScoreBreakdown(result: AnalysisResult): string {
    const { breakdown } = result.score;

    const bars = Object.entries(breakdown)
      .map(([key, value]) => {
        const label = this.formatLabel(key);
        const bar = this.generateProgressBar(value);
        return `- **${label}:** ${bar} ${value}/100`;
      })
      .join('\n');

    return `## Quality Score Breakdown

${bars}`;
  }

  private generateMetricsDetails(result: AnalysisResult): string {
    const { metrics } = result;

    return `## Detailed Metrics

### ðŸ“ Documentation
- README: ${metrics.documentation.hasReadme ? 'âœ…' : 'âŒ'} (Quality: ${metrics.documentation.readmeQuality}/100)
- Contributing Guidelines: ${metrics.documentation.hasContributing ? 'âœ…' : 'âŒ'}
- License: ${metrics.documentation.hasLicense ? 'âœ…' : 'âŒ'}
- Changelog: ${metrics.documentation.hasChangelog ? 'âœ…' : 'âŒ'}
- API Documentation: ${metrics.documentation.apiDocumentation ? 'âœ…' : 'âŒ'}

### ðŸ§ª Testing
- Tests Present: ${metrics.testing.hasTests ? 'âœ…' : 'âŒ'}
- CI/CD: ${metrics.testing.hasCICD ? 'âœ…' : 'âŒ'}
${metrics.testing.testCoverage ? `- Coverage: ${metrics.testing.testCoverage}%` : ''}

### ðŸ‘¥ Community
- Contributors: ${metrics.community.contributors}
- Code of Conduct: ${metrics.community.hasCodeOfConduct ? 'âœ…' : 'âŒ'}
- Issue Templates: ${metrics.community.hasIssueTemplates ? 'âœ…' : 'âŒ'}
- PR Templates: ${metrics.community.hasPRTemplates ? 'âœ…' : 'âŒ'}
- Health Score: ${metrics.community.communityHealthScore}/100

### ðŸ”’ Security
- Security Policy: ${metrics.security.hasSecurityPolicy ? 'âœ…' : 'âŒ'}
- Known Vulnerabilities: ${metrics.security.vulnerabilities}
- Security Score: ${metrics.security.securityScore}/100

### ðŸ’» Code Quality
- Lines of Code: ${metrics.codeQuality.linesOfCode.toLocaleString()}
${metrics.codeQuality.maintainabilityIndex ? `- Maintainability Index: ${metrics.codeQuality.maintainabilityIndex}/100` : ''}`;
  }

  private generateRecommendations(result: AnalysisResult): string {
    const recommendations = result.score.recommendations
      .map((rec, i) => `${i + 1}. ${rec}`)
      .join('\n');

    return `## ðŸ’¡ Recommendations

${recommendations}`;
  }

  private generateFooter(_result: AnalysisResult): string {
    return `---

*Report generated by Administrator - AI-powered repository analyzer*`;
  }

  private generateProgressBar(value: number): string {
    const filled = Math.floor(value / 10);
    const empty = 10 - filled;
    return 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(empty);
  }

  private formatLabel(key: string): string {
    return key
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, (str) => str.toUpperCase())
      .trim();
  }
}

export default ReportGenerator;
